ОБЫЧНЫЙ - 
# Техническое Задание: Архитектура Пользователей и Ролевая Модель (RBAC)

**Тип платформы:** Централизованная Онлайн-школа (EdTech LMS) **Модель управления:** Вертикальная (Администратор владеет данными, Тьюторы — наемные сотрудники).

## 1. Иерархия Ролей (System Roles)

Система строится на строгом разделении прав доступа. Пользователь имеет одну фиксированную роль в системе.

### 1.1. Super Admin (Владелец / Администратор)

- **Уровень доступа:** God Mode.
    
- **Функции:**
    
    - Управление сотрудниками (найм/блокировка Тьюторов).
        
    - Доступ ко всей финансовой аналитике.
        
    - Управление глобальным контентом (Банк заданий, Курсы).
        
    - Ручное переназначение учеников (смена преподавателя).
        
    - Просмотр любых чатов и логов (аудит).
        

### 1.2. Tutor (Преподаватель / Сотрудник)

- **Уровень доступа:** Ограниченный (Scoped Access).
    
- **Функции:**
    
    - Видит _только_ назначенных ему Учеников и Группы.
        
    - Ведет расписание и проверяет ДЗ.
        
    - Не видит контакты других учеников школы.
        
    - Не может удалять пользователей.
        
    - _Особенность:_ Может видеть профиль Родителя, привязанного к его Ученику (для связи).
        

### 1.3. Student (Ученик)

- **Уровень доступа:** Потребитель.
    
- **Функции:**
    
    - Доступ к Личному Кабинету (ЛК).
        
    - Решение задач, просмотр своих материалов.
        
    - Видит только свой прогресс.
        

### 1.4. Parent (Родитель / Наблюдатель) — _Новая роль_

- **Уровень доступа:** Read-Only (Наблюдатель).
    
- **Функции:**
    
    - Привязывается к одному или нескольким аккаунтам Students.
        
    - **Видит:** Статистику, Посещаемость, Баланс, Комментарии преподавателя, Расписание.
        
    - **Действия:** Оплата обучения, Чат с поддержкой/Администратором.
        
    - **Ограничение:** Не может решать задачи за ученика, не может писать Тьютору напрямую (если это запрещено политикой школы), не видит внутреннюю "кухню" обучения других детей.
        

## 2. Схема Базы Данных (ER-Diagram Description)

Используем реляционную модель. Ключевой принцип: отделение данных авторизации от профиля и использование связующих таблиц.

### 2.1. Таблица `users` (Ядро авторизации)

Хранит технические данные для входа.

- `id` (UUID, PK)
    
- `email` (Unique, Login)
    
- `password_hash`
    
- `role` (Enum: 'admin', 'tutor', 'student', 'parent')
    
- `is_active` (Boolean) — "Рубильник" доступа.
    
- `created_at`
    

### 2.2. Таблица `profiles` (Личные данные)

Расширенная информация. 1-to-1 связь с `users`.

- `user_id` (FK -> users.id)
    
- `first_name`
    
- `last_name`
    
- `middle_name` (Опционально)
    
- `phone` (Для SMS уведомлений)
    
- `telegram_id` (Для бота уведомлений)
    
- `timezone` (Важно! Ученик в МСК, Препод в НСК. Система должна конвертировать время).
    
- `avatar_url`
    

### 2.3. Таблица `family_ties` (Семейные связи)

Реализует связь "Многие-ко-многим" между Родителями и Учениками.

- `id` (PK)
    
- `parent_id` (FK -> users.id WHERE role='parent')
    
- `student_id` (FK -> users.id WHERE role='student')
    
- `access_level` (Enum: 'full', 'financial_only', 'schedule_only') — Гибкость настройки.
    
- `confirmed` (Boolean) — Подтверждение связи (чтобы чужой человек не добавил ребенка).
    

### 2.4. Таблица `enrollments` (Учебные контракты)

Связывает Ученика с Преподавателем по конкретному предмету.

- `id` (PK)
    
- `student_id` (FK)
    
- `tutor_id` (FK)
    
- `subject_id` (FK) — (Информатика, Математика и т.д.)
    
- `status` (Active, Paused, Archived)
    
- `settings` (JSON) — Индивидуальные настройки (например, цена часа для этого ученика, если отличается от стандартной).
    

## 3. Функциональные потоки (User Flows)

### 3.1. Регистрация Родителя и Привязка

В централизованной школе родители редко регистрируются сами "в пустоту".

**Сценарий А: "Инвайт от Школы" (Основной)**

1. Менеджер создает карточку Ученика.
    
2. Менеджер создает (или отправляет инвайт) Родителю.
    
3. Менеджер в админке связывает `parent_id` + `student_id`.
    
4. Родитель получает письмо: "Доступ к кабинету вашего ребенка Ивана открыт".
    

**Сценарий Б: "Семейный доступ" (Через ЛК Ученика)**

1. Ученик в ЛК заходит в "Настройки" -> "Моя семья".
    
2. Генерирует ссылку-приглашение.
    
3. Родитель переходит, регистрируется.
    
4. В `family_ties` создается запись.
    

### 3.2. Дашборд Родителя (Что видит)

При входе Родитель видит **Сводную панель**:

1. **Селектор ребенка:** Если детей двое, переключатель [Вася | Петя].
    
2. **Блок "Финансы":**
    
    - Остаток оплаченных уроков: 4 шт.
        
    - Кнопка "Пополнить баланс".
        
3. **Блок "Успеваемость" (AI Summary):**
    
    - "За эту неделю Вася решил 15 задач. Проблемная тема: Рекурсия. Прогноз балла ЕГЭ: 78".
        
4. **Блок "Календарь":**
    
    - Предстоящие уроки.
        
    - Статусы прошлых (Посетил / Прогулял / Отменен).
        

### 3.3. Видимость для Тьютора

Тьютор в карточке ученика видит секцию "Представители":

- Имя Родителя.
    
- Телефон/Телеграм (если разрешено настройками приватности школы).
    
- Кнопка "Связаться" (открывает чат внутри платформы, если политика школы разрешает прямое общение, либо тикет на менеджера).
    

## 4. Политики Безопасности и Приватности

### 4.1. Data Scoping (Ограничение видимости)

При любом запросе к API (например, `GET /api/grades`) сервер проверяет роль:

- Если `Admin`: `SELECT * FROM grades`
    
- Если `Tutor`: `SELECT * FROM grades WHERE student_id IN (мои ученики)`
    
- Если `Parent`: `SELECT * FROM grades WHERE student_id IN (мои дети)`
    
- Если `Student`: `SELECT * FROM grades WHERE student_id = me`
    

### 4.2. Защита от "Угона" базы

Так как Тьюторы — наемные сотрудники:

1. Реальные контакты учеников (телефон/email) скрыты маской в интерфейсе Тьютора (напр. `+7 900 *** ** 00`).
    
2. Общение только через внутренний мессенджер платформы.
    
3. Система алертов: Если Тьютор начинает массово выкачивать материалы или делать скриншоты базы (сложно отследить, но можно следить за частотой запросов к API профилей) — аккаунт блокируется.
    

## 5. Технический стек (Рекомендация)

- **Auth:** JWT (Access + Refresh tokens).
    
- **SSO:** Telegram Auth Widget (критично для Учеников и Родителей в РФ).
    
- **Backend:** Node.js (NestJS) или Python (Django/FastAPI).
    
- **Database:** PostgreSQL (надежность связей)


ТЕХНИЧЕСКИЙ ПЛАН - 

# Техническая спецификация (Implementation Plan)

## 1. Технологический Стек (Tech Stack)

Выбранная архитектура — **Modular Monolith** (Модульный монолит). Это позволит быстро разрабатывать систему сейчас и легко распилить её на микросервисы в будущем, если нагрузка вырастет.

- **Frontend (Web & PWA):** Next.js (React) + Tailwind CSS + ShadcnUI.
    
    - _Почему:_ SSR для SEO лендингов, отличная производительность дашбордов.
        
- **Backend:** NestJS (Node.js).
    
    - _Почему:_ Строгая типизация (TypeScript), отличная работа с DI, готовые модули для WebSocket и Auth.
        
- **Database:** PostgreSQL.
    
    - _ORM:_ Prisma (лучший DX и типизация схем).
        
- **Real-time:** Socket.io (встроено в NestJS Gateway).
    
- **Storage:** S3-compatible (MinIO для локальной разработки, AWS S3/Yandex Object Storage для продакшна).
    
- **DevOps:** Docker Compose (local), GitHub Actions (CI/CD).
    

## 2. Схема Базы Данных (Prisma Schema)

Ниже приведена структура ключевых моделей данных для реализации ролевой модели.

```
// --- ENUMS ---
enum Role {
  ADMIN
  TUTOR
  STUDENT
  PARENT
}

enum AccessLevel {
  FULL
  FINANCIAL_ONLY
  VIEW_ONLY
}

// --- MODELS ---

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  passwordHash  String
  role          Role      @default(STUDENT)
  isActive      Boolean   @default(true)
  
  // Relations
  profile       Profile?
  
  // Как ученик
  studentEnrollments Enrollment[] @relation("StudentEnrollments")
  studentParents     FamilyTie[]  @relation("StudentInFamily")
  
  // Как тьютор
  tutorEnrollments   Enrollment[] @relation("TutorEnrollments")
  
  // Как родитель
  parentChildren     FamilyTie[]  @relation("ParentInFamily")

  createdAt     DateTime  @default(now())
}

model Profile {
  id            String  @id @default(uuid())
  userId        String  @unique
  user          User    @relation(fields: [userId], references: [id])
  
  firstName     String
  lastName      String
  timezone      String  @default("Europe/Moscow")
  telegramId    String? // Для уведомлений
  avatarUrl     String?
  
  // Приватные заметки (видны только админу и тьютору)
  internalNotes String? @db.Text 
}

// Связь "Родитель - Ученик"
model FamilyTie {
  id          String      @id @default(uuid())
  
  parentId    String
  parent      User        @relation("ParentInFamily", fields: [parentId], references: [id])
  
  studentId   String
  student     User        @relation("StudentInFamily", fields: [studentId], references: [id])
  
  accessLevel AccessLevel @default(FULL)
  isConfirmed Boolean     @default(false)
  
  @@unique([parentId, studentId]) // Защита от дублей
}

// Учебный контракт (Связь "Ученик - Тьютор - Предмет")
model Enrollment {
  id        String   @id @default(uuid())
  
  studentId String
  student   User     @relation("StudentEnrollments", fields: [studentId], references: [id])
  
  tutorId   String
  tutor     User     @relation("TutorEnrollments", fields: [tutorId], references: [id])
  
  subject   String   // Например "INFORMATICS_EGE_2025"
  
  isActive  Boolean  @default(true)
  
  createdAt DateTime @default(now())
}
```

## 3. Реализация Безопасности (NestJS Guards)

Для реализации Data Scoping (чтобы Тьютор видел только своих), мы используем комбинацию Guards и Interceptors.

### 3.1. Auth Guard (JWT)

Стандартная проверка токена.

### 3.2. Scoped Access Middleware (Концепция)

Вместо того чтобы писать `WHERE` в каждом запросе, мы реализуем сервисный слой, который автоматически подмешивает фильтры.

**Пример логики сервиса `GradesService`:**

```
async getGrades(currentUser: User) {
  const whereClause: any = {};

  if (currentUser.role === Role.TUTOR) {
    // Найти всех учеников этого тьютора
    const myStudents = await this.prisma.enrollment.findMany({
      where: { tutorId: currentUser.id },
      select: { studentId: true }
    });
    const studentIds = myStudents.map(s => s.studentId);
    
    // Фильтр: оценки только этих учеников
    whereClause.studentId = { in: studentIds };
  } 
  
  else if (currentUser.role === Role.PARENT) {
    // Найти всех детей этого родителя
    const myChildren = await this.prisma.familyTie.findMany({
      where: { parentId: currentUser.id },
      select: { studentId: true }
    });
    const studentIds = myChildren.map(s => s.studentId);
    
    whereClause.studentId = { in: studentIds };
  }

  // Admin видит всё (whereClause пустой)
  return this.prisma.grade.findMany({ where: whereClause });
}
```

## 4. API Endpoints (Ключевые сценарии)

### Модуль Auth

- `POST /auth/login` — Возвращает JWT.
    
- `POST /auth/telegram-callback` — Валидация виджета TG и вход/регистрация.
    

### Модуль Users (Admin Only)

- `POST /users/tutor` — Создать преподавателя.
    
- `POST /users/student` — Создать ученика.
    

### Модуль Family (Для родителей)

- `POST /family/invite` (Student Scope) — Генерирует токен-ссылку.
    
- `GET /family/dashboard` (Parent Scope) — Агрегированные данные по всем детям.
    

### Модуль Edu (Обучение)

- `GET /edu/schedule` — Возвращает уроки с учетом таймзоны `profile.timezone`.
    
- `POST /edu/submit-solution` — Отправка кода (КЕГЭ). Здесь подключается микросервис проверки кода (Sandbox).
    

## 5. Особенности реализации инновационных фич

### 5.1. Telegram SSO и Уведомления

1. Используем официальный **Telegram Login Widget** на фронтенде.
    
2. При первом входе сохраняем `telegram_id` в `Profile`.
    
3. **NestJS Bull Queue (Redis):** Создаем очередь задач `notifications`.
    
    - Когда Тьютор ставит оценку -> событие летит в очередь.
        
    - Воркер берет событие, смотрит `telegram_id` ученика и родителя -> отправляет сообщение через бота.
        

### 5.2. Code Sandbox (Для Информатики)

Для безопасного запуска кода учеников (Python/C++):

1. Использовать **Piston** или **Judge0** (готовые open-source движки исполнения кода в Docker).
    
2. Backend отправляет код в API Judge0 -> получает stdout/stderr -> сравнивает с эталоном.
    

### 5.3. Real-time Dashboard ("Виртуальный коворкинг")

1. **WebSocket Gateway:**
    
    - Ученик заходит в раздел "Задачи".
        
    - Frontend шлет ивент: `socket.emit('enter_room', { roomId: 'global_coworking' })`.
        
2. **Server:**
    
    - Добавляет юзера в список "Online".
        
    - Бродкастит всем: `server.to('global_coworking').emit('user_joined', { name: 'Alex', task: 'Var 5' })`.
        
3. **Privacy:** Не передаем личные данные, только Имя и Аватар.
    

## 6. План Развертывания (DevOps)

Для стартапа достаточно одного VPS (например, 4 vCPU / 8GB RAM).

1. **Container 1 (App):** Node.js API.
    
2. **Container 2 (DB):** PostgreSQL.
    
3. **Container 3 (Cache/Queue):** Redis (для сокетов и очереди уведомлений).
    
4. **Container 4 (Proxy):** Nginx (SSL termination, reverse proxy).
    
5. **Backup:** Скрипт по крону делает `pg_dump` и льет в S3 раз в сутки.


# **Экспертный Отчет: Проектирование и Реализация Системы Автоматизированного Подбора Уникальных Заданий для Подготовки к КЕГЭ**

## **I. Введение и Обзор Архитектуры Решения**

### **1.1. Постановка Задачи и Цели Проекта**

Целью данного проекта является создание надежного и автономного инструмента, предназначенного для автоматизированного подбора заданий, специфичных для подготовки к экзамену по информатике (КЕГЭ). Ключевое требование к системе — это обеспечение уникальности каждого выдаваемого набора, что достигается за счет отслеживания истории использования заданий и исключения ранее выданных позиций из новых выборок. Система должна функционировать локально, без необходимости хостинга, и предоставлять удобный графический интерфейс (GUI), имитирующий веб\-сайт.

Проектная реализация должна включать три основных компонента: сбор данных (парсинг заданий), персистентное хранение данных (база данных) и пользовательское взаимодействие (веб-интерфейс). Особое внимание уделяется выбору технологий, которые обеспечат стабильность работы с динамическим контентом сайта-источника и эффективную работу с локальной базой данных.

### **1.2. Выбор Технологического Стека (Python Ecosystem)**

Для реализации данного решения выбран стек, основанный на экосистеме Python, что является оптимальным выбором для задач, сочетающих веб\-скрейпинг и обработку данных.

* **Язык:** Python. Стандартный выбор для инструментов обработки данных и автоматизации.  
* **Веб-Фреймворк (GUI):** **Flask**. Flask выбран как микрофреймворк, обеспечивающий необходимую гибкость и полный контроль над процессом обработки запросов (роутингом) и операциями CRUD (Create, Read, Update, Delete).1 Хотя существуют более простые инструменты для создания приложений, ориентированных на данные (например, Streamlit), Flask обеспечивает необходимую кастомизацию для построения сложной логики взаимодействия с историей использования заданий.  
* **База Данных:** **SQLite**. Это идеальное решение для локального, однопользовательского приложения. SQLite хранит всю информацию в одном файле (.db), не требуя настройки отдельного сервера базы данных, что соответствует требованию о локальном развертывании.3  
* **Парсинг:** **Playwright**. Данный инструмент является критически важным, поскольку современные образовательные сайты часто используют JavaScript для динамического рендеринга контента. Playwright, будучи инструментом для headless browsing, гарантирует корректную загрузку и извлечение контента, включая сложные элементы, такие как математические формулы и изображения.5

### **1.3. Высокоуровневая Архитектурная Схема**

Система будет построена по классическому принципу разделения ответственности на три уровня, что обеспечивает высокую модульность и упрощает поддержку:

1. **Уровень Сбора Данных (Data Acquisition Layer):** Отвечает за извлечение, очистку и структуризацию информации с внешнего ресурса. Модуль Playwright скачивает и рендерит веб\-страницы, извлекая структурированные данные заданий.  
2. **Уровень Хранения Данных (Persistence Layer):** Локальная база данных SQLite, управляемая ORM (Flask-SQLAlchemy), содержит две ключевые таблицы: Tasks (основной каталог заданий) и UsageHistory (история выдачи заданий).  
3. **Уровень Приложения и Представления (Application/Presentation Layer):** Микро-фреймворк Flask обрабатывает HTTP-запросы от локального браузера. Он использует специализированную логику для подбора уникальных заданий из БД, записывает факт использования в UsageHistory и отображает результаты через Jinja-шаблоны.

## **II. Стратегия Сбора Данных: Парсинг Заданий с "КЕГЭ"**

### **2.1. Правовые и Этические Аспекты Веб-Скрейпинга (Compliance Check)**

Перед началом автоматизированного сбора данных необходимо строго соблюдать правовые и этические нормы, установленные сайтом-источником. Это предотвращает блокировку IP-адреса и гарантирует уважительное отношение к ресурсу.

Проверка должна начинаться с анализа файла robots.txt.7 Программно эту проверку можно выполнить с помощью встроенной библиотеки Python urllib.robotparser.8 Эта библиотека позволяет определить, разрешено ли автоматическому агенту (User-agent: \*) получать доступ к конкретным URL-адресам, используемым для заданий. Кроме того, в robots.txt может быть указан параметр Crawl-delay, который регламентирует минимальный интервал между запросами.7 Встраивание этой проверки и соответствующей задержки в архитектуру парсера является обязательным начальным этапом для обеспечения надежности и долгосрочной работы инструмента.

### **2.2. Выбор Инструмента для Парсинга Динамического Контента**

Задания КЕГЭ, как правило, содержат сложный контент, включая математические формулы, часто рендерируемые с помощью JavaScript (например, MathJax), а также встроенные изображения. Простые парсеры, основанные только на HTTP-запросах (такие как Requests), не могут выполнить JavaScript, и, следовательно, не смогут получить полностью сформированный контент.

Инструмент **Playwright** решает эту проблему, запуская полнофункциональный "безголовый" (headless) браузер (Chromium, Firefox, или WebKit).5 Это позволяет скрипту взаимодействовать со страницей так, как это делает обычный пользователь, дожидаясь полной загрузки всех элементов. Playwright предоставляет методы для ожидания конкретных условий, например, page.wait\_for\_selector или page.wait\_for\_response, что критически важно для надежного сбора данных, поскольку гарантирует, что динамические элементы успели прогрузиться до извлечения информации.5

### **2.3. Структура Парсера: Извлечение текста, формул и изображений**

Для сохранения максимальной точности представления задания, извлеченный контент должен сохранять свое форматирование. Извлечение только чистого текста (plain text) приведет к потере формул, таблиц и изображений.

Playwright позволяет извлечь полный HTML-код нужного элемента, используя такие методы, как inner\_text() или page.$$eval().9 Рекомендуется сохранить полное, чистое HTML-содержимое задания в поле content\_html в таблице Tasks. Таким образом, приложение Flask сможет отобразить это содержимое в браузере, используя Jinja-шаблоны, без необходимости дополнительной обработки или потери форматирования.4

### **2.4. Рекомендации по Оптимизации и Первичному Заполнению Базы**

Процесс сбора всех заданий с сайта-источника может быть ресурсоемким и занимать значительное время. Для ускорения этого процесса и повышения эффективности системы рекомендуется рассматривать парсинг как отдельный ETL-процесс (Extract, Transform, Load).

Поскольку задания КЕГЭ меняются редко, основное приложение должно работать исключительно с локальной, быстродействующей базой данных, а не выполнять парсинг при каждом запросе. Сбор данных (E), очистка и запись в базу (T, L) должны быть декуплированы от основной логики приложения.

Для ускорения первоначальной загрузки данных можно использовать параллельную обработку. Playwright поддерживает асинхронный API, а также могут быть применены такие инструменты, как requests\_futures, для параллельной отправки запросов.11

Также рекомендуется сначала сохранять все сырые данные или HTML-страницы в локальную файловую систему, а затем отдельным скриптом выполнять очистку и запись в базу данных. Эта стратегия предотвращает блокировку сбора данных в случае сбоя при обработке и позволяет управлять объемом памяти, не допуская, чтобы растущий объем данных замедлял процесс скрейпинга.11 Для отслеживания актуальности данных в таблице Tasks необходимо предусмотреть поле last\_scraped, чтобы контролировать, когда задание было последний раз проверено на наличие изменений.12

## **III. Архитектура Хранения Данных: Проектирование Базы Данных SQLite**

### **3.1. Обоснование Выбора SQLite**

SQLite — это оптимальный выбор для локального, однопользовательского приложения.4 Главное преимущество состоит в том, что база данных полностью содержится в одном файле .db, что исключает необходимость настройки и поддержки отдельного сервера, такого как PostgreSQL или MySQL.3 Интеграция с Python является нативной, через стандартный модуль sqlite3.13 В контексте Flask, настоятельно рекомендуется использовать ORM, в частности, Flask-SQLAlchemy, которое абстрагирует работу с SQL, позволяя разработчику сосредоточиться на логике приложения.

### **3.2. Детализированная Схема Базы Данных (Data Model Blueprint)**

Для реализации ключевого требования — исключения ранее выданных заданий — необходимы две основные таблицы.

Таблица: Схема Базы Данных для Task Selector

| Таблица | Поле (Тип) | Описание | Связи/Ограничения |
| :---- | :---- | :---- | :---- |
| Tasks | task\_id (INTEGER) | Уникальный ID задания (Primary Key). | PK |
|  | task\_number (INTEGER) | Номер/тип задания (например, 1, 15, 27). | Индекс для быстрого поиска по типу |
|  | source\_url (TEXT) | Оригинальный URL на сайте КЕГЭ. |  |
|  | content\_html (TEXT) | Полное содержимое задания, включая формулы и изображения (для отображения). |  |
|  | last\_scraped (DATETIME) | Дата последнего обновления/парсинга данных задания. |  |
| UsageHistory | usage\_id (INTEGER) | Уникальный ID записи об использовании (Primary Key). | PK |
|  | task\_fk (INTEGER) | Foreign Key, ссылающийся на Tasks.task\_id. | FK to Tasks.task\_id |
|  | date\_issued (DATETIME) | Дата и время выдачи задания репетитору. |  |
|  | session\_tag (TEXT) | Опционально: ID сессии или ученика для дополнительной аналитики. |  |

### **3.3. Реализация CRUD-Операций через Flask-SQLAlchemy**

Использование Flask-SQLAlchemy значительно упрощает взаимодействие с определенной выше схемой. ORM позволяет определять классы Python, которые соответствуют таблицам (Tasks и UsageHistory), что делает операции создания (Create) новых записей о заданиях после парсинга и записи истории использования (Update/Create в UsageHistory) интуитивно понятными.3

### **3.4. Рекомендации по Обслуживанию и Бэкапу**

База данных заданий является критически важным активом. Для обеспечения надежности и предотвращения потери данных в случае повреждения локального файла БД необходимо реализовать механизм регулярного резервного копирования.

Модуль Python sqlite3 предоставляет API для создания онлайн-бэкапов через функцию backup(). Эта функция позволяет создать копию базы данных, даже если она активно используется Flask-приложением или другими клиентами, что предотвращает блокировку.13 Автоматизированный скрипт бэкапа (например, выполняемый при каждом запуске приложения или после крупного обновления данных парсером) должен быть интегрирован в приложение, обеспечивая надежное хранение данных.14

## **IV. Реализация Основной Логики: Случайный Выбор с Исключением**

Ключевая функциональность программы заключается в выполнении сложного запроса, который выбирает определенное количество ($N$) случайных заданий заданного типа ($K$), исключая те, которые уже были использованы.

### **4.1. Формулировка Запроса в Терминах SQL**

Задача сводится к выборке $N$ записей из таблицы Tasks, которые удовлетворяют двум условиям: 1\) соответствие заданному task\_number, и 2\) отсутствие соответствующей записи в UsageHistory.

### **4.2. Метод Исключающего Соединения (LEFT JOIN и NOT IN)**

Для эффективной фильтрации "использованных" заданий используются методы исключения. Традиционным методом является LEFT OUTER JOIN с фильтром WHERE tableB.id IS NULL.15 Это соединение показывает все задания из Tasks и сопоставляет их с UsageHistory. Задания, не имеющие сопоставленной истории, являются неиспользованными.

В данном случае, когда требуется выборка ID, которые отсутствуют в другой таблице, использование оператора NOT IN или NOT EXISTS также является эффективным и, для многих, более читабельным подходом.

### **4.3. Оптимизированный Случайный Выбор в SQLite**

SQLite предоставляет встроенную функцию RANDOM() для генерации псевдослучайных чисел.16 Для выборки случайных строк к отфильтрованному набору применяется сортировка ORDER BY RANDOM() с последующим ограничением числа строк с помощью LIMIT.18

Прямое использование ORDER BY RANDOM() может быть ресурсоемким на очень больших таблицах, поскольку требует сортировки всего результирующего набора. Однако для локальной базы данных SQLite, используемой для задач КЕГЭ, этот подход остается наиболее простым и надежным для получения истинно случайного распределения.18

### **4.4. Комбинированный SQL-Запрос (Blueprint) для подбора уникальных заданий**

Предлагается следующий оптимизированный SQL-шаблон, который будет выполняться Flask-приложением через ORM с подставленными параметрами (:task\_type и :limit\_count):

SQL

SELECT  
    T.\*  
FROM  
    Tasks AS T  
WHERE  
    T.task\_number \= :task\_type  
    \-- Исключающий подзапрос: выбираем только те ID, которые НЕ встречаются в UsageHistory  
    AND T.task\_id NOT IN (SELECT H.task\_fk FROM UsageHistory AS H)  
\-- Рандомизация и ограничение:  
ORDER BY  
    RANDOM()  
LIMIT  
    :limit\_count;

**Обработка Результатов и Фиксация Использования:**

После того как Flask-приложение выполнит этот запрос и получит список $N$ уникальных заданий, критически важным шагом является немедленная фиксация факта их использования. Для каждого выбранного task\_id в таблицу UsageHistory должна быть добавлена новая запись, фиксирующая текущую дату и время (date\_issued), что гарантирует, что эти задания будут исключены из последующих выборок.12

**Управление Исчерпанием Запаса Заданий:**

Программа должна быть спроектирована с учетом сценария, когда все задания определенного типа ($K$) были использованы. Если SQL-запрос возвращает пустой результат (ноль строк), приложение должно это распознать. В этом случае пользователю должна быть предложена опция сброса истории использования для данного типа заданий (функция "Reset Usage History") или запуск модуля парсинга для поиска новых задач на сайте-источнике.

## **V. Фронтенд и GUI: Выбор и Реализация Локального Веб-Интерфейса**

### **5.1. Сравнительный Анализ Фреймворков для Локального GUI**

Для создания веб\-интерфейса в локальной среде необходимо выбрать между инструментами, ориентированными на быстрый прототип (Streamlit) и более традиционными веб\-фреймворками (Flask).

Таблица: Сравнение Streamlit и Flask для Task Selector

| Критерий | Streamlit | Flask (с Jinja/HTML) | Вывод |
| :---- | :---- | :---- | :---- |
| **Назначение** | Быстрое прототипирование, приложения, ориентированные на данные 1 | Микрофреймворк, полный контроль над маршрутизацией и CRUD-логикой 2 |  |
| **Сложность Настройки** | Низкая, минимальная настройка 19 | Средняя, требуется определение маршрутов и шаблонов 3 |  |
| **Кастомизация UI/UX** | Ограниченная, фиксированный набор компонентов 19 | Высокая, полный контроль над внешним видом через HTML/CSS/JS 1 |  |
| **Поддержка Сложной Логики БД** | Требует обходных путей для управления состоянием | Нативна, идеален для сложной логики CRUD и управления историей 2 |  |

Несмотря на простоту Streamlit, выбор Flask является более обоснованным, поскольку проект требует не только отображения данных, но и сложной логики управления состоянием (запись истории использования, выполнение оптимизированных SQL-запросов), а также полного контроля над отображением контента заданий (HTML-рендеринг формул). Flask обеспечивает необходимый контроль и архитектуру для создания полноценного CRUD-приложения.1

### **5.2. Архитектура Flask-Приложения**

Приложение Flask должно придерживаться стандартной структуры для обеспечения чистоты и поддерживаемости кода 3:

* **app.py:** Выступает в качестве точки входа, где происходит инициализация Flask, Flask-SQLAlchemy, а также определяются все маршруты (routes) и функции обработки запросов.  
* **templates/:** Директория для хранения всех HTML-шаблонов Jinja2, которые Flask использует для отображения динамически сгенерированного контента (например, index.html для формы ввода, results.html для отображения заданий).  
* **static/:** Директория для хранения статических файлов, таких как CSS для стилизации и JavaScript, если это необходимо для интерактивности.

### **5.3. Реализация Пользовательского Интерфейса (GUI)**

Интерфейс должен быть простым и функциональным:

1. **Главная Страница (/ или index.html):** Должна содержать форму для генерации набора.  
   * Поле выбора типа задания (например, выпадающий список, содержащий номера заданий 1, 2, 10 и т.д., взятых из таблицы Tasks).  
   * Поле ввода количества заданий (с валидацией, ограничивающей диапазон, например, от 1 до 10).  
   * Кнопка "Сгенерировать Набор".  
2. **Страница Результатов (/results):** Отображается после успешной генерации.  
   * Задания должны быть представлены в виде, который корректно рендерит content\_html, сохраняя формулы и разметку.  
   * Должно быть отображено подтверждение того, что история использования была записана.  
   * Рекомендуется добавить дополнительную функцию для сохранения отображаемого набора, например, в виде PDF или чистого HTML-файла.

### **5.4. Взаимодействие Фронтенда и Бэкенда (API)**

Основное взаимодействие происходит через маршрут /generate (метод POST).

1. Когда пользователь отправляет форму, Flask получает тип задания и требуемое количество.  
2. Приложение вызывает функцию, реализующую логику подбора уникальных заданий (Раздел IV), используя оптимизированный SQL-запрос.  
3. При успешном подборе, выполняется запись в UsageHistory.  
4. Приложение рендерит шаблон results.html, передавая ему данные выбранных заданий.

Для обеспечения стабильности и безопасности, даже в локальном приложении, настоятельно рекомендуется использовать такие инструменты, как Flask-WTF для обработки веб\-форм. Это обеспечивает валидацию пользовательского ввода и защиту от атак CSRF (Cross-Site Request Forgery), что повышает общую надежность приложения.3

## **VI. Интеграция, Структура Проекта и Развертывание**

### **6.1. Общая Модульная Структура Проекта (Separation of Concerns)**

Для обеспечения структурированности и удобства разработки, проект должен быть разделен на функциональные модули:

/keg\_selector\_app/  
├── venv/                       \# Виртуальное окружение  
├── data/  
│   └── keg\_tasks.db            \# Файл базы данных SQLite  
├── scraper/  
│   └── playwright\_parser.py    \# Модуль для парсинга и ETL  
├── core/  
│   └── db\_models.py            \# Модели SQLAlchemy (Tasks, UsageHistory)  
│   └── selector\_logic.py       \# Функции SQL-запросов (логика подбора)  
├── templates/                  \# Шаблоны Jinja2 для GUI  
│   └── index.html  
│   └── results.html  
├── static/                     \# Статические файлы (CSS/JS)  
└── app.py                      \# Главный файл Flask, роутинг  
└── requirements.txt            \# Зависимости

### **6.2. Пошаговый План Запуска и Зависимости**

Для развертывания системы необходима следующая последовательность действий:

1. **Создание Среды:** Инициализация и активация виртуального окружения Python (python3 \-m venv venv).3  
2. **Установка Зависимостей:** Установка ключевых библиотек (pip install flask flask-sqlalchemy playwright) и установка необходимых браузеров для Playwright (playwright install).  
3. **Инициализация DB:** Запуск скрипта для создания файла keg\_tasks.db и определения таблиц Tasks и UsageHistory.  
4. **Первичное Заполнение:** Однократный запуск модуля playwright\_parser.py для сбора заданий и заполнения таблицы Tasks.  
5. **Запуск Сервера:** Запуск главного приложения Flask (python app.py). Приложение станет доступным по локальному адресу (обычно http://127.0.0.1:5000), работая как локальный сайт.

### **6.3. Рекомендации по Окончательному Упаковыванию Приложения**

Поскольку пользователь не должен быть системным администратором или разработчиком, наиболее простым способом развертывания является предоставление ему активированного виртуального окружения и четкой инструкции по запуску app.py.

Если требуется создание исполняемого файла, который не требует установки Python, можно рассмотреть упаковку приложения. Традиционные инструменты, такие как PyInstaller, могут создавать сложности при упаковке Flask-приложений, особенно с учетом необходимости включения шаблонов Jinja и файлов базы данных. Более современный подход может использовать **Briefcase**, который является рекомендованным инструментом для упаковки сложных Python-приложений, использующих веб\-интерфейсы, в автономные исполняемые файлы (.exe,.app).20 Использование Docker, хотя и является лучшей инженерной практикой для обеспечения системной агностичности, может быть избыточно сложным для инструмента, предназначенного для одного пользователя в локальной среде.21

## **VII. Заключение и Перспективы Развития**

Разработанная архитектура, основанная на Flask, SQLite и Playwright, предоставляет надежное и масштабируемое решение для автоматизированного подбора уникальных заданий КЕГЭ. Ключевым элементом надежности является разделение процесса сбора данных от основной логики приложения и использование двойной схемы БД (Tasks и UsageHistory) для обеспечения уникальности выборок.

### **Заключительные Рекомендации**

1. **Приоритет ETL:** Следует воспринимать парсинг как отдельный, периодический процесс обновления каталога, а не как часть ежедневной работы приложения.  
2. **Немедленная Фиксация:** Критически важно, чтобы запись в UsageHistory происходила сразу после выбора задания, но до его отображения пользователю, чтобы исключить возможность повторной выдачи в параллельных запросах.  
3. **Обработка Исчерпания:** Необходимо включить в интерфейс функционал сброса истории для тех типов заданий, которые были полностью использованы.

### **Перспективы Развития Системы**

На основе предложенной структуры возможны следующие расширения функционала:

1. **Персонализированная История Использования:** Использование поля session\_tag в таблице UsageHistory позволит отслеживать, какому конкретному ученику или группе был выдан набор заданий.  
2. **Фильтрация по Сложности:** Добавление поля difficulty (например, 1–5) в таблицу Tasks позволит пользователю фильтровать выборку не только по типу, но и по предполагаемой сложности.  
3. **Инструменты Аналитики:** Разработка дополнительного маршрута Flask для создания простого дашборда, который визуализирует статистику: частоту использования заданий по типу, дату последнего обновления каталога и общее количество доступных/использованных задач.  
4. **Функция Бэкапа:** Создание отдельного маршрута в Flask, который инициирует неблокирующий онлайн-бэкап базы данных, используя API sqlite3.backup(), для защиты данных.13

#### **Works cited**

1. Streamlit vs. Flask: A Comparative Analysis for Building CRUD Operations with MongoDB | by Mysterious obscure | Medium, accessed November 6, 2025, [https://medium.com/@mysterious\_obscure/streamlit-vs-flask-a-comparative-analysis-for-building-crud-operations-with-mongodb-3dc98ecc32fe](https://medium.com/@mysterious_obscure/streamlit-vs-flask-a-comparative-analysis-for-building-crud-operations-with-mongodb-3dc98ecc32fe)  
2. Flask CRUD Application Tutorial with SQLite: Step-by-Step Guide \- YouTube, accessed November 6, 2025, [https://www.youtube.com/watch?v=KO0FufpqC7c](https://www.youtube.com/watch?v=KO0FufpqC7c)  
3. Building a Basic CRUD App with SQLite and Flask | by Emmanuel ..., accessed November 6, 2025, [https://medium.com/@echilaka/building-a-basic-crud-app-with-sqlite-and-flask-75de9b8bee68](https://medium.com/@echilaka/building-a-basic-crud-app-with-sqlite-and-flask-75de9b8bee68)  
4. Web scraping: How do I store data? : r/AskProgramming \- Reddit, accessed November 6, 2025, [https://www.reddit.com/r/AskProgramming/comments/s09ag6/web\_scraping\_how\_do\_i\_store\_data/](https://www.reddit.com/r/AskProgramming/comments/s09ag6/web_scraping_how_do_i_store_data/)  
5. Playwright for Python Web Scraping Tutorial with Examples \- ScrapingBee, accessed November 6, 2025, [https://www.scrapingbee.com/blog/playwright-for-python-web-scraping/](https://www.scrapingbee.com/blog/playwright-for-python-web-scraping/)  
6. Playwright Web Scraping Tutorial for 2025 \- Oxylabs, accessed November 6, 2025, [https://oxylabs.io/blog/playwright-web-scraping](https://oxylabs.io/blog/playwright-web-scraping)  
7. Python Web Scraping: Full Tutorial With Examples (2025) \- ScrapingBee, accessed November 6, 2025, [https://www.scrapingbee.com/blog/web-scraping-101-with-python/](https://www.scrapingbee.com/blog/web-scraping-101-with-python/)  
8. Parsing Robots.txt in python \- Stack Overflow, accessed November 6, 2025, [https://stackoverflow.com/questions/43085744/parsing-robots-txt-in-python](https://stackoverflow.com/questions/43085744/parsing-robots-txt-in-python)  
9. Web Scraping with Playwright in 6 Simple Steps \- ScrapingAnt, accessed November 6, 2025, [https://scrapingant.com/blog/playwright-web-scraping-guide](https://scrapingant.com/blog/playwright-web-scraping-guide)  
10. Web Scraping With Playwright, accessed November 6, 2025, [https://scrape.do/blog/web-scraping-with-playwright/](https://scrape.do/blog/web-scraping-with-playwright/)  
11. How can I optimize a web-scraping code snippet to run faster? \- Stack Overflow, accessed November 6, 2025, [https://stackoverflow.com/questions/59915322/how-can-i-optimize-a-web-scraping-code-snippet-to-run-faster](https://stackoverflow.com/questions/59915322/how-can-i-optimize-a-web-scraping-code-snippet-to-run-faster)  
12. sqlite \- What is the correct database structure to store historical data? \- Stack Overflow, accessed November 6, 2025, [https://stackoverflow.com/questions/42477570/what-is-the-correct-database-structure-to-store-historical-data](https://stackoverflow.com/questions/42477570/what-is-the-correct-database-structure-to-store-historical-data)  
13. sqlite3 — DB-API 2.0 interface for SQLite databases — Python 3.14.0 documentation, accessed November 6, 2025, [https://docs.python.org/3/library/sqlite3.html](https://docs.python.org/3/library/sqlite3.html)  
14. How to Use SQLite's Online Backup API in Python, accessed November 6, 2025, [https://blog.sqlite.ai/sqlite-python-backup](https://blog.sqlite.ai/sqlite-python-backup)  
15. Get records from Table A, that are not in Table B \- Stack Overflow, accessed November 6, 2025, [https://stackoverflow.com/questions/16844206/get-records-from-table-a-that-are-not-in-table-b](https://stackoverflow.com/questions/16844206/get-records-from-table-a-that-are-not-in-table-b)  
16. SQLite RANDOM() Function By Practical Examples, accessed November 6, 2025, [https://www.sqlitetutorial.net/sqlite-functions/sqlite-random/](https://www.sqlitetutorial.net/sqlite-functions/sqlite-random/)  
17. Python Sqlite: How would you randomly select a value-specific row? \- Stack Overflow, accessed November 6, 2025, [https://stackoverflow.com/questions/48338901/python-sqlite-how-would-you-randomly-select-a-value-specific-row](https://stackoverflow.com/questions/48338901/python-sqlite-how-would-you-randomly-select-a-value-specific-row)  
18. Select random row(s) \- Stack Overflow, accessed November 6, 2025, [https://stackoverflow.com/questions/4114940/select-random-rows](https://stackoverflow.com/questions/4114940/select-random-rows)  
19. The Advantages of Using Streamlit, Flask and Django for Building Web Apps \- Akra Tech, accessed November 6, 2025, [https://akratech.com/advantages-of-streamlit-flask-django/](https://akratech.com/advantages-of-streamlit-flask-django/)  
20. How to package a python desktop app for Windows with briefcase \- Medium, accessed November 6, 2025, [https://medium.com/@nohkachi/how-to-package-a-python-desktop-app-for-windows-with-briefcase-a270cf05da17](https://medium.com/@nohkachi/how-to-package-a-python-desktop-app-for-windows-with-briefcase-a270cf05da17)  
21. How to make windows standalone exe for python flask/jinja/sqlite application \[duplicate\], accessed November 6, 2025, [https://stackoverflow.com/questions/45182755/how-to-make-windows-standalone-exe-for-python-flask-jinja-sqlite-application](https://stackoverflow.com/questions/45182755/how-to-make-windows-standalone-exe-for-python-flask-jinja-sqlite-application)